// UNIQUE PATHS III

/*  PROBLEM:
    On a 2-dimensional grid, there are 4 types of squares:

    1 represents the starting square. There is exactly one starting square.
    2 represents the ending square. There is exactly one ending square.
    0 represents empty squares we can walk over.
    -1 represents obstacles that we cannot walk over.

    Return the number of 4-directional walks from the starting square to the ending square, 
    that walk over every non-obstacle square exactly once.
*/

/*  EXAMPLES:

    Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
    Output: 2
    Explanation: We have the following two paths: 
    1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
    2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

    Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
    Output: 4
    Explanation: We have the following four paths: 
    1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
    2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
    3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
    4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

    Input: [[0,1],[2,0]]
    Output: 0
    Explanation: 
    There is no path that walks over every empty square exactly once.
    Note that the starting and ending square can be anywhere in the grid.
*/

/*  APPROACH: Depth-First-Search - O(3^n)
    DFS Helper Function
    1. If the row and column pointers go out of bounds or if a cell contains a -1, return 0.
    2. If the destination has been reached and if the number of steps taken is equal to the total number of valid cells, return 1, since each valid cell must be visited.
    3. Mark each cell as visited.
    4. Calculate the total number of paths by adding the paths generated by traversing each adjacent cell.
    5. Reset the cells as unvisited by backtracking.

    Unique Paths Function
    1. Traverse the grid to identify the starting position and count the number of walkable cells.
    2. Recursively call the DFS function to investigate each possible path.
*/

// SOLUTION:
#include <bits/stdc++.h>

using namespace std;

class Solution {
public:
    int DFS(vector<vector<int>>& grid, int i, int j, int steps, int valid_cells) {
        // Check invalid conditions
        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == -1) {
            return 0;
        }
        // Destination has been reached
        if(grid[i][j] == 2) {
            // Check if the number of steps is equal to the number of total valid cells
            return steps == valid_cells ? 1 : 0;
        }
        // Mark visited cells
        grid[i][j] = -1;
        // Calculate the total number of paths by exploring each adjacent cell through DFS
        int paths = DFS(grid, i + 1, j, steps + 1, valid_cells) +
                    DFS(grid, i - 1, j, steps + 1, valid_cells) +
                    DFS(grid, i, j + 1, steps + 1, valid_cells) +
                    DFS(grid, i, j - 1, steps + 1, valid_cells);
        // Reset the cells as unvisited by backtracking
        grid[i][j] = 0;
        return paths;
    }
    
    int uniquePathsIII(vector<vector<int>>& grid) {
        int i_pos = 0, j_pos = 0, valid_cells = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                // Identify the starting position index
                if(grid[i][j] == 1) {
                    i_pos = i;
                    j_pos = j;
                }
                // Count the number of walkable cells
                if(grid[i][j] != -1) {
                    valid_cells++;
                }
            }
        }
        return DFS(grid, i_pos, j_pos, 1, valid_cells);
    }
};
